PRD: Agent Runtime Service (Privileged, Superuser-only)
Project name and folder: agent-worker

Purpose

Provide a privileged agent runtime that can execute LLM-driven development tasks (code edits, tests, inspections) on a hobby VPS, with Rails(Sleeve) as the sole session master, queue, and monitor.

This service runs agents with full host access for superuser workflows only.

⸻

Key decisions (locked in)
	•	Rails sends all system text
	•	No prompt files or personalities stored in the worker.
	•	Worker treats Rails input as authoritative.
	•	Rails owns queueing and monitoring
	•	Only one agent run at a time for now.
	•	Rails waits for completion before dispatching the next job.
	•	Worker does not queue.
	•	Single workspace (for now)
	•	Workspace root: ~/projects
	•	Agent can:
	•	edit code in multiple repos under that tree
	•	run tests, linters, scripts
	•	No per-session sandboxing yet.
	•	Future multi-workspace support is allowed but out of scope.
	•	Superuser-only
	•	All tools enabled.
	•	No command restrictions or allowlists.
	•	Guardrails are about accident prevention, not security isolation.
	•	Pi is an implementation detail
	•	Service name and API must be vendor-neutral.
	•	Embedding Pi SDK is acceptable and recommended.
	•	Superuser-only use case
	•	Regular-user traffic uses direct LLM APIs (out of scope).
	•	pi-regular-users will be deprecated after this implementation.

⸻

High-level architecture

Components

1. Rails Gateway(Sleeve) (authoritative)
	•	Owns:
	•	session history (canonical)
	•	job queue (ActiveJob / SolidQueue)
	•	run lifecycle (queued → running → finished / failed)
	•	audit log (assistant output + tool events)
	•	Decides:
	•	when a run starts
	•	what history is sent
	•	when to compact/summarize
	•	No Rails changes in this phase (worker-only build)

2. Agent Runtime Service (privileged worker)
	•	Node/TS service embedding Pi SDK
	•	Executes exactly one run per request
	•	No persistent session authority
	•	Executes tools directly on host filesystem

⸻

Execution model

One-turn-per-run (hard rule)
	•	Rails dispatches one run.
	•	Worker executes until:
	•	agent produces final assistant message, or
	•	hard failure occurs.
	•	Worker exits run and returns result.
	•	Rails may enqueue next run.

No background autonomy, no self-looping beyond a single run.
	•	If worker is busy, return 409.
	•	run_id is idempotent; duplicate returns cached result or 409 with prior status.

⸻

API contract (internal)

POST /runs

Request
	•	run_id (UUID, generated by Rails)
	•	session_id
	•	messages[] (full canonical history or summary + tail, includes newest user message)
	•	Rails-normalized (OpenAI-style) roles:
	•	system
	•	user
	•	assistant
	•	tool_call
	•	tool_result
	•	model_config
	•	provider
	•	model
	•	temperature
	•	max_tokens
	•	workspace_cwd (optional, default ~/projects)
	•	run_timeout_ms (optional)
	•	tool_timeout_ms (optional)
	•	max_output_bytes (optional)

Worker assumptions
	•	All system instructions are already included.
	•	No hidden prompt state.
	•	Messages are authoritative.
	•	workspace_cwd must stay within workspace root.

Response
	•	run_id
	•	session_id
	•	assistant_message (final content blocks + finish_reason)
	•	events[]
	•	tool_call
	•	tool_result
	•	log
	•	usage
	•	status (ok / error)
	•	error (if any)
	•	truncated (if any output truncated)
	•	full_output_path (if truncated)
	•	MVP: return only the Pi `turn_end` message payload (no deltas/events)

Additional endpoints
	•	POST /runs/:id/abort
	•	POST /runs/:id/interrupt (steer or follow_up)
	•	GET /runs/:id
	•	GET /status (readiness + busy state)

⸻

Workspace and tooling

Workspace
	•	Single workspace root: ~/projects
	•	Worker process runs with:
	•	cwd = ~/projects
	•	full read/write access

Tools
	•	Enabled:
	•	bash
	•	filesystem access (via bash or explicit fs tool)
	•	No restrictions, allowlists, or deny lists.
	•	Output captured and returned to Rails:
	•	stdout
	•	stderr
	•	exit code
	•	duration
	•	truncated flag + full_output_path when output exceeds limits

Responsibility split
	•	Worker: executes tools, captures output.
	•	Rails: stores and displays tool activity.

⸻

Deployment (Kamal-compatible)

Recommended: Dockerized worker (with host mounts)
	•	Build a Node image containing:
	•	agent runtime service
	•	Pi SDK
	•	Run via Kamal as a separate service.
	•	Mount:
	•	$HOME/projects:/home/agent/projects
	•	Run container as a normal user (not root).

Why Docker even with full access
	•	Reproducible builds
	•	Easy redeploy/rollback
	•	Still gives full access to development directories

If later you want true host-level ops, you can add more mounts or move to systemd without changing the API.

⸻

Observability

Rails (source of truth)
	•	Job status:
	•	queued
	•	running
	•	finished
	•	failed
	•	Stores:
	•	assistant messages
	•	tool logs
	•	timestamps
	•	usage

Worker
	•	Structured logs:
	•	run_id
	•	tool execution
	•	errors
	•	Minimal metrics:
	•	run duration
	•	tool count
	•	GET /status reports readiness + busy state
	•	SIGUSR2 emits a JSON status snapshot

⸻

Failure handling
	•	Worker returns structured error:
	•	tool failure
	•	model error
	•	timeout
	•	Rails:
	•	marks job failed
	•	retains partial tool logs
	•	allows retry (manual or automatic)

No automatic retries inside worker.

Testing
	•	Unit tests required for core logic.
	•	Endpoint checks via curl in addition to unit tests.

⸻

Milestones (updated)

Sprint 1 — Minimal runtime
	•	Node service scaffold
	•	/runs endpoint
	•	Pi SDK embedded
	•	Single run → return only `turn_end` message
	•	Dockerfile + Kamal service
	•	Unit tests for request validation + run lifecycle
	•	Curl script examples for /runs and /status

Exit: Worker accepts runs and returns responses via curl + tests.

⸻

Sprint 2 — Bash + dev workflows
	•	bash tool integration
	•	cwd = ~/projects
	•	Capture stdout/stderr/exit code
	•	Unit tests for tool event shaping
	•	Curl examples for tool output + truncation

Exit: Worker can run bash and return tool output.

⸻

Sprint 3 — Queue + reliability
	•	Enforce “one run at a time”
	•	Timeout handling
	•	Clear run lifecycle states
	•	Idempotent run_id
	•	Busy → 409
	•	Unit tests for idempotency + busy behavior

Exit: Worker enforces single-run + idempotent runs.

⸻

Sprint 4 — Streaming (optional)
	•	Worker emits SSE events
	•	Useful for long test runs
	•	Curl example using `--no-buffer` or `-N`

Exit: Streaming works directly from worker.

⸻

Sprint 5 — Compaction (Rails-side)
	•	Deferred until Rails changes are in scope

Exit: Placeholder for future Rails integration.

